package service

import (
	"context"

	"github.com/1mb-dev/nivomoney/services/wallet/internal/models"
	"github.com/1mb-dev/nivomoney/services/wallet/internal/repository"
	"github.com/1mb-dev/nivomoney/shared/errors"
	"github.com/1mb-dev/nivomoney/shared/logger"
)

// VirtualCardService handles business logic for virtual card operations.
type VirtualCardService struct {
	cardRepo   *repository.VirtualCardRepository
	walletRepo *repository.WalletRepository
	logger     *logger.Logger
}

// NewVirtualCardService creates a new virtual card service.
func NewVirtualCardService(cardRepo *repository.VirtualCardRepository, walletRepo *repository.WalletRepository) *VirtualCardService {
	return &VirtualCardService{
		cardRepo:   cardRepo,
		walletRepo: walletRepo,
		logger:     logger.NewDefault("wallet.card"),
	}
}

// CreateCard creates a new virtual card for a wallet.
func (s *VirtualCardService) CreateCard(ctx context.Context, walletID, userID string, req *models.CreateVirtualCardRequest) (*models.VirtualCard, *errors.Error) {
	// Verify wallet exists and belongs to user
	wallet, err := s.walletRepo.GetByID(ctx, walletID)
	if err != nil {
		return nil, err
	}

	if wallet.UserID != userID {
		return nil, errors.Forbidden("wallet does not belong to user")
	}

	// Check wallet is active
	if wallet.Status != models.WalletStatusActive {
		return nil, errors.BadRequest("wallet is not active")
	}

	// Create the card
	card := &models.VirtualCard{
		WalletID:       walletID,
		UserID:         userID,
		CardHolderName: req.CardHolderName,
	}

	if createErr := s.cardRepo.Create(ctx, card); createErr != nil {
		return nil, createErr
	}

	s.logger.With(map[string]interface{}{
		"card_id":   card.ID,
		"wallet_id": walletID,
	}).Info("Virtual card created")

	return card, nil
}

// GetCard retrieves a virtual card by ID.
func (s *VirtualCardService) GetCard(ctx context.Context, cardID, userID string) (*models.VirtualCard, *errors.Error) {
	card, err := s.cardRepo.GetByID(ctx, cardID)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if card.UserID != userID {
		return nil, errors.Forbidden("card does not belong to user")
	}

	return card, nil
}

// ListCards retrieves all virtual cards for a wallet.
func (s *VirtualCardService) ListCards(ctx context.Context, walletID, userID string) ([]*models.VirtualCardResponse, *errors.Error) {
	// Verify wallet exists and belongs to user
	wallet, err := s.walletRepo.GetByID(ctx, walletID)
	if err != nil {
		return nil, err
	}

	if wallet.UserID != userID {
		return nil, errors.Forbidden("wallet does not belong to user")
	}

	cards, listErr := s.cardRepo.ListByWallet(ctx, walletID)
	if listErr != nil {
		return nil, listErr
	}

	// Convert to responses (masked data)
	responses := make([]*models.VirtualCardResponse, len(cards))
	for i, card := range cards {
		responses[i] = card.ToResponse()
	}

	return responses, nil
}

// FreezeCard freezes a virtual card.
func (s *VirtualCardService) FreezeCard(ctx context.Context, cardID, userID, reason string) (*models.VirtualCard, *errors.Error) {
	// Verify ownership
	card, err := s.cardRepo.GetByID(ctx, cardID)
	if err != nil {
		return nil, err
	}

	if card.UserID != userID {
		return nil, errors.Forbidden("card does not belong to user")
	}

	if card.Status != models.CardStatusActive {
		return nil, errors.BadRequest("can only freeze active cards")
	}

	if freezeErr := s.cardRepo.Freeze(ctx, cardID, reason); freezeErr != nil {
		return nil, freezeErr
	}

	s.logger.With(map[string]interface{}{
		"card_id": cardID,
		"reason":  reason,
	}).Info("Virtual card frozen")

	// Return updated card
	return s.cardRepo.GetByID(ctx, cardID)
}

// UnfreezeCard unfreezes a virtual card.
func (s *VirtualCardService) UnfreezeCard(ctx context.Context, cardID, userID string) (*models.VirtualCard, *errors.Error) {
	// Verify ownership
	card, err := s.cardRepo.GetByID(ctx, cardID)
	if err != nil {
		return nil, err
	}

	if card.UserID != userID {
		return nil, errors.Forbidden("card does not belong to user")
	}

	if card.Status != models.CardStatusFrozen {
		return nil, errors.BadRequest("can only unfreeze frozen cards")
	}

	if unfreezeErr := s.cardRepo.Unfreeze(ctx, cardID); unfreezeErr != nil {
		return nil, unfreezeErr
	}

	s.logger.WithField("card_id", cardID).Info("Virtual card unfrozen")

	// Return updated card
	return s.cardRepo.GetByID(ctx, cardID)
}

// CancelCard cancels a virtual card permanently.
func (s *VirtualCardService) CancelCard(ctx context.Context, cardID, userID, reason string) (*models.VirtualCard, *errors.Error) {
	// Verify ownership
	card, err := s.cardRepo.GetByID(ctx, cardID)
	if err != nil {
		return nil, err
	}

	if card.UserID != userID {
		return nil, errors.Forbidden("card does not belong to user")
	}

	if card.Status == models.CardStatusCancelled {
		return nil, errors.BadRequest("card is already cancelled")
	}

	if cancelErr := s.cardRepo.Cancel(ctx, cardID, reason); cancelErr != nil {
		return nil, cancelErr
	}

	s.logger.With(map[string]interface{}{
		"card_id": cardID,
		"reason":  reason,
	}).Info("Virtual card cancelled")

	// Return updated card
	return s.cardRepo.GetByID(ctx, cardID)
}

// UpdateCardLimits updates the spending limits for a virtual card.
func (s *VirtualCardService) UpdateCardLimits(ctx context.Context, cardID, userID string, req *models.UpdateCardLimitsRequest) (*models.VirtualCard, *errors.Error) {
	// Verify ownership
	card, err := s.cardRepo.GetByID(ctx, cardID)
	if err != nil {
		return nil, err
	}

	if card.UserID != userID {
		return nil, errors.Forbidden("card does not belong to user")
	}

	// Only active and frozen cards can have limits updated
	if card.Status == models.CardStatusCancelled || card.Status == models.CardStatusExpired {
		return nil, errors.BadRequest("cannot update limits for cancelled or expired cards")
	}

	if updateErr := s.cardRepo.UpdateLimits(ctx, cardID, req.DailyLimit, req.MonthlyLimit, req.PerTransactionLimit); updateErr != nil {
		return nil, updateErr
	}

	s.logger.WithField("card_id", cardID).Info("Virtual card limits updated")

	// Return updated card
	return s.cardRepo.GetByID(ctx, cardID)
}

// RevealCardDetails reveals the full card details (requires additional security in production).
// Note: CVV is only returned during card creation and cannot be revealed afterward.
func (s *VirtualCardService) RevealCardDetails(ctx context.Context, cardID, userID string) (*models.RevealCardDetailsResponse, *errors.Error) {
	// Verify ownership
	card, err := s.cardRepo.GetByID(ctx, cardID)
	if err != nil {
		return nil, err
	}

	if card.UserID != userID {
		return nil, errors.Forbidden("card does not belong to user")
	}

	// Check if card is expired
	if card.IsExpired() {
		return nil, errors.BadRequest("cannot reveal details for expired card")
	}

	// Check card status - allow reveal for active and frozen cards
	if card.Status == models.CardStatusCancelled {
		return nil, errors.BadRequest("cannot reveal details for cancelled card")
	}

	// In production, this would require:
	// 1. Additional authentication (OTP, biometric, etc.)
	// 2. Rate limiting
	// 3. Audit logging

	// CVV is hashed in storage and cannot be decrypted.
	// It is only provided during card creation.
	// Users who need CVV must request a new card.

	s.logger.With(map[string]interface{}{
		"card_id": cardID,
		"user_id": userID,
	}).Info("Card details revealed")

	return &models.RevealCardDetailsResponse{
		CardNumber:  card.CardNumber,
		ExpiryMonth: card.ExpiryMonth,
		ExpiryYear:  card.ExpiryYear,
		CVV:         "", // CVV cannot be revealed post-creation (hashed in storage)
	}, nil
}
